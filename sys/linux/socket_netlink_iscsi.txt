include <uapi/linux/netlink.h>
include <include/scsi/iscsi_if.h>
include <include/linux/net.h>

resource sock_nl_iscsi[sock]
#resource session_id[int32]

syz_init_net_socket$nl_iscsi(domain const[AF_NETLINK], type const[SOCK_RAW], proto const[NETLINK_ISCSI]) sock_nl_iscsi
sendmsg$CREATE_SESSION(fd sock_nl_iscsi, msg ptr[inout, user_msghdr_iscsi[netlink_msg_create_session]], f flags[send_flags])

type user_msghdr_iscsi[MSG] {
	addr	ptr[in, sockaddr_nl_kern]
	addrlen	len[addr, int64]
	vec	ptr[in, iovec_iscsi[inout, MSG]]
	vlen	const[1, int64]
	ctrl	const[0, int64]
	ctrllen	const[0, int64]
	f	flags[send_flags, int64]
}

type iovec_iscsi[DIR, MSG] {
	iov_base	ptr[DIR, MSG]
	iov_len		len[iov_base, int64]
}

netlink_msg_create_session {
	len		const[72, int32]
	type		const[ISCSI_UEVENT_CREATE_SESSION, int16]
	flags		flags[netlink_msg_flags, int16]
	seq		netlink_seq
	pid		netlink_port_id
#msg head len 16
	u		iscsi_uevent_head
#iscsi_uevent head len  16
	initial_cmdsn	int32
	cmds_max	int16
	queue_depth	int16
	pad_u		array[const[0, int8], 16]
#user union len 24
	sid		int32
	host_no		int32
	pad_r		array[const[0, int8], 8]
#ret union len 16
}

iscsi_uevent_head {
	type			int32
	iferror			int32
	transport_handle	const[18446744071650678464, int64]
}
